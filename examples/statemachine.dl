typeset statemachine = [
  type main = stm stm_processor?;
  type stm = 'statemachine' "[a-zA-Z0-9]*" '{' config state* '}';
  type config = 'initialState' ':' "[a-zA-Z0-9]*";
  type state = 'state' "[a-zA-Z0-9]*" '{' transition entry* '}';
  type entry = (onEnter | onExit | onRead);
  type onEnter = 'onEnter' '{' statement* '}';
  type onExit = 'onExit' '{' statement* '}';
  type onRead = 'onRead' '{' statement* '}';
  type stm_number = "[0-9]*";
  type stm_operator = '==' | '>=' | '<' | '>' | '<=';
  type transition = 'transition' ':' "[a-zA-Z0-9]*" 'when' stm_operator stm_number;
  type stm_processor = 'stm_process' identifier "[a-zA-Z0-9]*" "[0-9]*"; 
]

match(main) 
{
  |=> {
    $0 $1 
  }
}

match(stm)
{
  |=> {
    let @states = []
    $3
    $4
  }
}

match(config)
{
  |=> {
    let @config_initialState = "$2.value"
  }
}

match(state)
{
  |=> {

    let @state_name = "$1.value"
    @states["$1.value"] = [$3 $4]
  }
}

match(transition)
{
  |=> {
    "transitionName" = "$2.value" 
    "transitionOperator" = "$4.value"
    "transitionNumber" = $5.value
    "fun" = function (@value : string, @num : int)  {
      return @value $4.value @num
    }

  }
}

match(entry)
{
   | => {
      $0
   }
}

match(onEnter)
{
   |=> {
      "onEnter" = function () 
      {      
        $2.value      
      }
   }
}

match(onExit)
{
   |=> {
      "onExit" = function () 
      {      
        $2.value      
      }
   }
}

match(onRead)
{
   |=> {
      "onRead" = function () 
      {      
        $2.value      
      }
   }
}


match(stm_processor)
{
  |=> {

    let @currentState = @config_initialState   
    let @transitions = @states[@config_initialState]
   
    let @operator = @transitions["transitionOperator"]

    let @onEnter = @transitions["onEnter"]
    @onEnter()

    let @index = 1
    for(@index = 1, $3.value, 1) {

    let @transitions = @states[@currentState]
    let @fun = @transitions["fun"]
    @onEnter = @transitions["onEnter"]
    let @onExit = @transitions["onExit"]

	if(@fun($1.value[@index] @transitions["transitionNumber"]))
        {
          @onExit()
          @currentState = @transitions["transitionName"]
	  @transitions = @states[@currentState] 
          @onEnter = @transitions["onEnter"]
          @onEnter()
        }

      let @onRead = @transitions["onRead"]
      @onRead()
    }
  }
}

let @table = [0 1 2 3 4 5 6 7 8 9 2 3]

statemachine basic
{
  initialState : below5

  state below5 {
    transition : above5 when >= 5
    onEnter
    {      
      @print("Entering below5")
    }
    onExit
    {
      @print("Exitting below5")      
    }
    onRead
    {
      @print("Reading below5")      
    }
  }

  state above5 {
    transition : below5 when < 5
    onEnter
    {      
      @print("Entering above5")
    }
    onExit
    {
      @print("Exitting above5")      
    }
    onRead
    {
      @print("Reading above5")      
    }
  }
}

stm_process @table ab 12
