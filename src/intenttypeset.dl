
typeset intent = [

  type program = statement*;

  type compound_statement = '{' statement* '}';

  type statement = 
              ( let_statement 
              | function_declaration
              | compound_statement
              | while_loop
              | for_loop
              | if_statement
              | return_statement
              |	expression
              | match
              | extension);

  type expression = 
                ( literal
                | bin_expr 
                | unary_expression
                | function_call
                | table 
                | function_expression);

  type if_statement =   'if' '(' expression ')' statement property!(right, 6000)
                       | 'if' '(' expression ')' statement 'else' statement property!(right,6100);

  type while_loop = 'while' '(' expression ')' statement;

  type for_loop = 'for' '(' expression ','  expression ',' expression ')' statement;

  type bin_expr =
       expression bin_op expression
     | '(' expression ')';


  type bin_op = '.' property!(binary_op_left, 30)
              | '+' property!(binary_op_left, 25)
  	          | '-' property!(binary_op_left, 25)
  	          | '*' property!(binary_op_left, 30)
  	          | '/' property!(binary_op_left, 30)
  	          | '<' property!(binary_op_left, 20)
  	          | '>' property!(binary_op_left, 20)
  	          | '<='property!(binary_op_left, 20)
  	          | '>='property!(binary_op_left, 20)
  	          | '=='property!(binary_op_left, 20)
  	          | '!='property!(binary_op_left, 20)
  	          | '&&'property!(binary_op_left, 10)
  	          | '||'property!(binary_op_left, 10)
  	          | '=' property!(binary_op_left, 10);


  type unary_expression = '!' expression | identifier table_element;
     
  type let_statement = 'let' identifier (':' identifier)? '=' expression ;

  type type_ex               = ('string' | 'int' | 'bool' | 'any');

  type parameter           = identifier (':' type_ex)?;

  type argument           = expression;

  type function_declaration  = 'function' identifier '(' parameter? (',' parameter)* ')' (':' type_ex)? function_body;

  type function_expression  = 'function' '(' parameter? (',' parameter)* ')' (':' type_ex)? function_body;

  type function_body = compound_statement;

  type function_call = identifier '(' argument* ')' ;

  type return_statement = 'return' expression ;

  type bool = ('true' | 'false');

  type table_element = '[' literal ']' ;
  type literal = (number | string | bool | identifier);

  type table = '[' expression*  ']';

  type identifier       = "@[a-zA-Z_][a-zA-Z_0-9]*" ;

  type number             = "[0-9][0-9]*" ;

  type string =  "\"([^\"\\]|\\[^])*\"";

  type whitespace = ( "[ \t\r\n]+" 
                 | singleLineComment 
                 | multiLineComment 
                 | nestedComment )* ;

  type singleLineComment = '//' "[^\n]*" '\n';

  type multiLineComment = '/*' ( "[^*]" | '*'+ "[^*\/]" )* '*'+ '/';

  type nestedComment = '/+' ( nestedComment 
                        | ( "[^+]" 
                        | '+'+ "[^+\/]" )* '+'+ )* ( "[^+]" 
                        | '+'+ "[^+\/]" )* '+'+ '/';


  type match_id = "[a-zA-Z_][a-zA-Z_0-9]*";

  type match = 'match' '(' match_id ')' '{' match_case + '}' ;

  type code = "[\+\-;:,_<>$@#=a-zA-Z0-9{} \t\(\)\"\?\.\^\[\]]"*;
 
  type match_case = '|' number? '=>' '{' code '}';

  type extension = main;

  type main = ;
]

